<?php
/**
 * Copyright 2023 DPD France S.A.S.
 *
 * This file is a part of dpdfrance module for Prestashop.
 *
 * NOTICE OF LICENSE
 *
 * This file is subject to the Academic Free License (AFL 3.0)
 * that is bundled with this package in the file LICENSE.md.
 * It is also available through the world-wide-web at this URL:
 * http://opensource.org/licenses/afl-3.0.php
 *
 * DISCLAIMER
 *
 * Do not edit this file if you wish to upgrade this module to newer
 * versions in the future. If you wish to customize this module for
 * your needs please contact us at support.ecommerce@dpd.fr.
 *
 * @author    DPD France S.A.S. <support.ecommerce@dpd.fr>
 * @copyright 2023 DPD France S.A.S.
 * @license   http://opensource.org/licenses/afl-3.0.php  Academic Free License (AFL 3.0)
 */

namespace PrestaShop\Module\DPDFrance\ExternalContentProvider;

use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcription\Eprint\Address;
use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcription\Eprint\BcDataExt;
use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcription\Eprint\Label;
use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcription\Eprint\RetourServices;
use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcription\Eprint\RetourShipmentDataBc;
use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcription\Eprint\ShipmentBc;
use PrestaShop\Module\DPDFrance\ExternalContentProvider\Transcriptor\Transcriptor;
use SoapClient;
use SoapFault;
use SoapHeader;
use stdClass;

/**
 * Provider d'appel du webservice d'impression des étiquettes
 *
 * Développé pour la version 1.6 du Webservice EPrint
 *
 * C'est aussi dans ce service que sont créés les expéditions Dpd (cf createShipment)
 */
class EprintProvider
{
    // Webservice Eprint sur l'environnement de Production
    const EPRINT_URL_PROD = 'https://e-station.cargonet.software/dpd-eprintwebservice/eprintwebservice.asmx?WSDL';
    // Webservice Eprint sur l'environnement de TEST pour réaliser des tests avec des colis "test"
    const EPRINT_URL_TEST = 'https://e-station-testenv.cargonet.software/eprintwebservice/eprintwebservice.asmx?WSDL';

    /**
     * @var SoapClient|null
     * @method stdClass CreateShipmentBc(array $request)
     * @method stdClass CreateShipment(array $request)
     * @method stdClass GetLabelBc(array $request)
     * @method stdClass GetLabel(array $request)
     * @method stdClass GetRetourLabelBc(array $request)
     * @method stdClass GetRetourLabel(array $request)
     * @method stdClass GetRetourShipmentDataBc(array $request)
     * @method stdClass GetRetourShipmentData(array $request)
     */
    private static $soapClient = null;

    /**
     * @var stdClass{
     *    'userid': string,
     *    'password': string,
     * }
     */
    private static $auth;

    /**
     * Doit-on utiliser l'environnement de test ?
     *
     * @var bool
     */
    private static $useTestEnv;

    /**
     * @param string $user
     * @param string $password
     * @param bool|null $useTestEnv
     * @return bool
     */
    public static function initSoapClient(string $user, string $password, bool $useTestEnv = false)
    {
        // On évite d'initialiser la classe si celle-ci l'a déjà été avec les mêmes paramètres.
        if (
            self::$soapClient instanceof SoapClient
            && self::$auth instanceof stdClass
            && self::$auth->userid === $user
            && self::$auth->password === $password
            && self::$useTestEnv === $useTestEnv
        ) {
            return true;
        }
        $url = $useTestEnv === false ? self::EPRINT_URL_PROD : self::EPRINT_URL_TEST;

        try {
            $soapClient = new SoapClient(
                $url,
                [
                    'connection_timeout' => 5,
                    'cache_wsdl'         => WSDL_CACHE_NONE,
                    'exceptions'         => true,
                ]
            );
            self::$auth = new stdClass();
            self::$auth->userid = $user;
            self::$auth->password = $password;
            $header = new SoapHeader('http://www.cargonet.software', 'UserCredentials', self::$auth, false);
            $soapClient->__setSoapHeaders($header);
        } catch (SoapFault $exception) {
            return false;
        }

        self::$soapClient = $soapClient;
        self::$useTestEnv = $useTestEnv;

        return true;
    }

    /* Fonctions d'appel au webservice */

    /**
     * Création d'une expédition
     *
     * @param array{
     *    'customer_countrycode': int,
     *    'customer_centernumber': int,
     *    'customer_number': int,
     *    'receiveraddress': Address[],
     *    'receiverinfo': array|null,
     *    'shipperaddress': Address[],
     *    'shippingdate': string|null,
     *    'retouraddress': Address[]|null,
     *    'services': array|null,
     *    'weight': string,
     *    'referencenumber': string|null,
     * } $request
     * @param bool $bc Forcer l'utilisation de la requête Bc
     *
     * @return ShipmentBc[]
     */
    public static function createShipment(array $request, bool $bc)
    {
        $shipments = [];

        if ($bc) {
            $response = self::$soapClient->CreateShipmentBc([
                'request' => $request,
            ]);

            /**
             * @var StdClass|StdClass[] $shipmentsBc
             */
            $shipmentsBc = $response->CreateShipmentBcResult->ShipmentBc;

            if (!is_array($shipmentsBc)) {
                $shipmentsBc = [$shipmentsBc];
            }

            foreach ($shipmentsBc as $shipmentBc) {
                $shipments[] = Transcriptor::convertTo(ShipmentBc::class, $shipmentBc, [
                    'Shipment' => BcDataExt::class,
                ]);
            }
        } else {
            $response = self::$soapClient->CreateShipment([
                'request' => $request,
            ]);
            $shipmentsDpc = $response->CreateShipmentResult->Shipment;

            if (!is_array($shipmentsDpc)) {
                $shipmentsDpc = [$shipmentsDpc];
            }

            foreach ($shipmentsDpc as $shipmentDpc) {
                // Conversion du Shipment déprécié en faux ShipmentBc (c'est Iso !)
                $shipmentDpc->Type = $shipmentDpc->type;
                $shipmentDpc->Shipment = new stdClass();
                $shipmentDpc->Shipment->BarcodeId = (string)$shipmentDpc->parcelnumber;
                $shipmentDpc->Shipment->BarcodeSource = $shipmentDpc->countrycode;
                $shipmentDpc->Shipment->BarCode = (string)$shipmentDpc->barcode;
                unset($shipmentDpc->type);
                unset($shipmentDpc->centernumber);
                unset($shipmentDpc->parcelnumber);
                unset($shipmentDpc->countrycode);
                unset($shipmentDpc->barcode);

                $shipments[] = Transcriptor::convertTo(ShipmentBc::class, $shipmentDpc, [
                    'Shipment' => BcDataExt::class,
                ]);
            }
        }

        // ** Remarques **
        // $shipments[0] contient l'expédition (vérifiable avec ->Type === 'EPRINT')
        // $shipments[1] contient l'éventuel retour (vérifiable avec ->Type === 'REVERSE')
        return $shipments;
    }

    /**
     * Étiquette d'expédition
     *
     * @param array{
     *    'countrycode': int,
     *    'centernumber': int,
     *    'customer_number': int,
     *    'parcelnumber': int,
     *    'labelType': array{
     *        'type': string,
     *    }
     * } $request
     * @param bool $bc Forcer l'utilisation de la requête Bc
     *
     * @return Label[]
     */
    public static function getLabel(array $request, bool $bc)
    {
        if ($bc) {
            $bcRequestParams = [
                'customer'       => [
                    'countrycode'  => $request['countrycode'],
                    'centernumber' => $request['centernumber'],
                    'number'       => $request['customer_number'],
                ],
                'shipmentNumber' => $request['parcelnumber'],
                'labelType'      => $request['labelType'],
            ];

            $response = self::$soapClient->GetLabelBc([
                'request' => $bcRequestParams,
            ]);

            $labelsEp = $response->GetLabelBcResult->labels->Label;
        } else {
            unset($request['customer_number']);

            if (self::isGeolabel($request['parcelnumber'])) {
                // Pour les Geolabel, countrycode et centernumber doivent être à 0
                $request['countrycode'] = '0';
                $request['centernumber'] = '0';
            }

            $request['parcelnumber'] = (int)$request['parcelnumber'];

            $response = self::$soapClient->GetLabel([
                'request' => $request,
            ]);

            $labelsEp = $response->GetLabelResult->labels->Label;
        }

        if ($labelsEp instanceof stdClass) {
            $labelsEp = [$labelsEp];
        }

        $labels = [];
        foreach ($labelsEp as $labelEp) {
            $labels[] = Transcriptor::convertTo(Label::class, $labelEp);
        }

        return $labels;
    }

    /**
     * Étiquette de retour
     *
     * @param array{
     *    'countrycode': string,
     *    'centernumber': string,
     *    'customer_number': string,
     *    'parcelnumber': string,
     *    'receiveraddress': array{
     *        'name': string,
     *        'countryPrefix': string,
     *        'zipCode': string,
     *        'city': string,
     *        'street': string,
     *        'phoneNumber': string,
     *    }|null,
     *    'labelType': array{
     *        'type': string,
     *    }
     * } $request
     * @param bool $bc Forcer l'utilisation de la requête Bc
     *
     * @return Label[]
     */
    public static function getRetourLabel(array $request, bool $bc)
    {
        if ($bc) {
            $bcRequestParams = [
                'customer'       => [
                    'countrycode'  => $request['countrycode'],
                    'centernumber' => $request['centernumber'],
                    'number'       => $request['customer_number'],
                ],
                'shipmentNumber' => $request['parcelnumber'],
                'labelType'      => $request['labelType'],
            ];

            if (isset($request['receiveraddress'])) {
                $bcRequestParams['receiveraddress'] = $request['receiveraddress'];
            }

            $response = self::$soapClient->GetRetourLabelBc([
                'request' => $bcRequestParams,
            ]);

            $labelsEp = $response->GetRetourLabelBcResult->labels->Label;
        } else {
            unset($request['customer_number']);

            $response = self::$soapClient->GetRetourLabel([
                'request' => $request,
            ]);

            $labelsEp = $response->GetRetourLabelResult->labels->Label;
        }

        if ($labelsEp instanceof stdClass) {
            $labelsEp = [$labelsEp];
        }

        $labels = [];
        foreach ($labelsEp as $labelEp) {
            $labels[] = Transcriptor::convertTo(Label::class, $labelEp);
        }

        return $labels;
    }

    /**
     * Informations de retour
     *
     * @param array{
     *    'countrycode': int,
     *    'centernumber': int,
     *    'customer_number': int,
     *    'original_parcelnumber': int,
     * } $request
     * @param bool $bc Forcer l'utilisation de la requête Bc
     *
     * @return RetourShipmentDataBc
     */
    public static function getRetourShipmentData(array $request, bool $bc)
    {
        if ($bc) {
            $bcRequestParams = [
                'customer'          => [
                    'countrycode'  => $request['countrycode'],
                    'centernumber' => $request['centernumber'],
                    'number'       => $request['customer_number'],
                ],
                'originalBarcodeId' => $request['original_parcelnumber'],
            ];

            $response = self::$soapClient->GetRetourShipmentDataBc([
                'request' => $bcRequestParams,
            ]);

            $retourShipmentDataStd = $response->GetRetourShipmentDataBcResult;
        } else {
            unset($request['customer_number']);

            if (self::isGeolabel($request['original_parcelnumber'])) {
                $request['countrycode'] = '0';
                $request['centernumber'] = '0';
            }

            $response = self::$soapClient->GetRetourShipmentData([
                'request' => $request,
            ]);

            $retourShipmentDataStd = $response->GetRetourShipmentDataResult;

            // On adapte le $retourShipmentDataStd en faux format Bc (c'est Iso !)
            $retourShipmentDataStd->shipment = new stdClass();
            $retourShipmentDataStd->shipment->BarcodeId = $retourShipmentDataStd->parcelnumber;
            $retourShipmentDataStd->shipment->BarcodeSource = $retourShipmentDataStd->countrycode;
            $retourShipmentDataStd->shipment->BarCode = null;
            $retourShipmentDataStd->shipmentRetour = new stdClass();
            $retourShipmentDataStd->shipmentRetour->BarcodeId = $retourShipmentDataStd->parcelnumber_retour;
            $retourShipmentDataStd->shipmentRetour->BarcodeSource = $retourShipmentDataStd->countrycode_retour;
            $retourShipmentDataStd->shipmentRetour->BarCode = null;
            unset($retourShipmentDataStd->parcelnumber);
            unset($retourShipmentDataStd->countrycode);
            unset($retourShipmentDataStd->centernumber);
            unset($retourShipmentDataStd->parcelnumber_retour);
            unset($retourShipmentDataStd->countrycode_retour);
            unset($retourShipmentDataStd->centernumber_retour);
        }

        return Transcriptor::convertTo(
            RetourShipmentDataBc::class,
            $retourShipmentDataStd,
            [
                'shipperaddress'  => Address::class,
                'customeradress'  => Address::class,
                'receiveraddress' => Address::class,
                'shipment'        => BcDataExt::class,
                'shipmentRetour'  => BcDataExt::class,
                'services'        => RetourServices::class,
            ]
        );
    }

    /**
     * Teste si un parcel_number/barcode_id est un Geolabel ou non
     * @param $parcelNumber
     * @return bool
     */
    private static function isGeolabel($parcelNumber)
    {
        return
            strlen($parcelNumber) === 14
            && substr($parcelNumber, 0, 3) != '250'
        ;
    }
}
